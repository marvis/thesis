\chapter{Fast marching method} \label{chpt:fm}
Fast marching(FM) method \cite{sethian1999level} plays a very important part in both automatic neuron tracing (APP2 method) and human-guided neuron tracing. It is essentially a region-growing scheme and can be used for GSDT and initial neuron reconstruction in APP2 and finding shortest path between rays in human-guided neuron tracing.
\section{Introduction}
\subsection{Algorithm flow}
In FM, we model an image as a graph, where each graph vertex corresponds to an image pixel (voxel). There is an edge between each pair of immediately neighboring pixel-vertices. FM grows the image graph from a set of predefined seed vertices to all remaining image pixel-vertices in a distance-increasing order.  All image pixels are divided into three groups, labeled as \emph{ALIVE}, \emph{TRIAL} and \emph{FAR}. 

FM has two main steps: initialization and recursion. First, all the seed vertices are initialized to be \emph{ALIVE}; the neighbors of seeds are initialized as \emph{TRIAL}; and the rest are set as \emph{FAR}. Then, from the set of \emph{TRIAL} vertices, we will extract one vertex x, which has the minimum distance value to the \emph{ALIVE} set. The extracted vertex x is then converted from \emph{TRIAL} to \emph{ALIVE}.  For any non-\emph{ALIVE} neighbor y of x, we set it to \emph{TRIAL} if it is \emph{FAR}. The distance function of y is updated as (also see below for concrete definitions)
\begin{equation}
d(y)=min‚Å°{d(y),d(x)+e(x,y)}
\end{equation}

where $e(x,y)$ is the distance between vertex $x$ and vertex $y$ (see below for definition of $e(x,y)$). FM recursively extracts the vertex that has the minimum-distance from the \emph{TRIAL} set until it becomes empty.
An important implementation trick of FM is to maintain \emph{TRIAL} vertices in a Fibonacci heap so that the required minima can be obtained efficiently. See Alg.\ref{alg:fast-marching} for the algorithm flow of FM.

\begin{algorithm}[H]
\label{alg:fast-marching}
\SetKwInOut{Input}{Input}\SetKwInOut{Output}{Output}
\SetAlgoLined
\Input{seed points $x_0,x_1,\ldots,x_n$}
\Output{Return distance map $d(x)$}
Initialize distance map $d(x) = \infty$ for all point and mark as \emph{FAR} \;
Initialize $d(x_0),d(x_1),\ldots,d(x_n)$ to $0$ and mark it as \emph{ALIVE} \;
Initialize queue of \emph{TRIAL} points $Q = \O$ \;
Mark \emph{FAR} neighbors of \emph{ALIVE} points as \emph{TRIAL} (add to $Q$) and update $d$ \;
\While{Q is not empty}{
Remove minimum point $x$ from $Q$, mark $x$ as \emph{ALIVE}\;
Mark \emph{FAR} neighbors of $x$ as \emph{TRIAL} and insert into $Q$\; 
Update $d$ for the neighbors of $x$\;
}
\caption{Fast marching algorithm}
\end{algorithm}
\subsection{Min Heap}

\subsection{Differnce from dijkstra's algorithm}
In general, fast marching method is the same to Dijkstra's algorithm except that FM applys dynamic weight function. In fast marhcing method, the weight for each edge can be calculate when the edge is under marching.
\section{Applications}
\subsection{Shortest path between any shapes}

\subsection{Gray-weighted distance transfrom}
\subsection{Generalized voronoi diagram for shapes} \label{subsec:gvd}
